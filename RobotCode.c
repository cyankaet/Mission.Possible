#pragma config(Sensor, in1,    temp,           sensorReflection)
#pragma config(Sensor, in2,    light,          sensorReflection)
#pragma config(Sensor, dgtl2,  ledBoop1,       sensorDigitalOut)
#pragma config(Sensor, dgtl3,  ledBoop2,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  ledBoop3,       sensorDigitalOut)
#pragma config(Sensor, dgtl5,  ledBoop4,       sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ledBoop5,       sensorDigitalOut)
#pragma config(Sensor, dgtl7,  ledBoop6,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledBoop7,       sensorDigitalOut)
#pragma config(Sensor, dgtl9,  ledBoop8,       sensorDigitalOut)
#pragma config(Sensor, dgtl10, ledBoop9,       sensorDigitalOut)
#pragma config(Sensor, dgtl11, wind,           sensorQuadEncoder)
#pragma config(Motor,  port2,           flag,          tmotorNone, openLoop)
#pragma config(Motor,  port3,           quad,          tmotorVex393_MC29, openLoop, encoderPort, None)
#pragma config(Motor,  port4,           leftMotor,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           rightMotor,    tmotorVex393_MC29, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
*everything on the left is negated because of mirrored motors
*/
#define HALF_SPEED 63;
#define FULL_SPEED 127;
#define STATIONARY 0;
#define BACK_HALF -63;
#define BACK_FULL -127;
int temps[10];

/*
*turn left without moving forward, pivot turn
*/
void left()
{
	motor[rightMotor] = 63;
	motor[leftMotor] = 63;
	wait1Msec(500);
	motor[rightMotor] = STATIONARY;
	motor[leftMotor] = STATIONARY;
}

void right()
{
	motor[leftMotor] = -63;
	motor[rightMotor] = -63;
	wait1Msec(500);
	motor[rightMotor] = STATIONARY;
	motor[leftMotor] = STATIONARY;
}
void dropFlag()
{
	motor[flag] = 30;
	wait1Msec(500);
	motor[flag] = STATIONARY;
}
void pullGravel()
{
	motor[flag] = -30;
	wait1Msec(500);
	motor[flag] = STATIONARY;
}

void autoMove() {
	//left 1.23
	motor[rightMotor] = 63;
	motor[leftMotor] = 63;
	wait1Msec(1230);
	//straight 3.63
	motor[rightMotor] = 63;
	motor[leftMotor] = -63;
	wait1Msec(3630);
	//left 2.7
	motor[rightMotor] = 63;
	motor[leftMotor] = 63;
	wait1Msec(2800);
}


void toBinary(int num) {
	//number to convert to binary
	int n=num;
	writeDebugStreamLine("input num (decimal): %d", n);

	wait1Msec(1000);

	// array to store binary number
	int binaryNum[9];
	//setting the whole array to 0
	for (int j = 0; j < 9; j++) {
		binaryNum[j]=0;
	}
	// counter for binary array,
	int i = 0;
	while (n > 0) {
		binaryNum[i]= n % 2;
		n = n / 2;
		i++;
	}
	// printing binary array in reverse order
	for (int j = 8; j >=0; j--) {
		writeDebugStream("%d", binaryNum[j]);
	}
	if(binaryNum[0]==1){
		SensorValue[ledBoop1] = false;
	}
	if(binaryNum[1]==1){
		SensorValue[ledBoop2] = false;
	}
	if(binaryNum[2]==1){
		SensorValue[ledBoop3] = false;
	}
	if(binaryNum[3]==1){
		SensorValue[ledBoop4] = false;
	}
	if(binaryNum[4]==1){
		SensorValue[ledBoop5] = false;
	}
	if(binaryNum[5]==1){
		SensorValue[ledBoop6] = false;
	}
	if(binaryNum[6]==1){
		SensorValue[ledBoop7] = false;
	}
	if(binaryNum[7]==1){
		SensorValue[ledBoop8] = false;
	}
	if(binaryNum[8]==1){
		SensorValue[ledBoop9] = false;
	}
	wait1Msec(3000);
	wait1Msec(1000);
	SensorValue[ledBoop1] = true;
	wait1Msec(300);
	SensorValue[ledBoop2] = true;
	wait1Msec(300);
	SensorValue[ledBoop3] = true;
	wait1Msec(300);
	SensorValue[ledBoop4] = true;
	wait1Msec(300);
	SensorValue[ledBoop5] = true;
	wait1Msec(300);
	SensorValue[ledBoop6] = true;
	wait1Msec(300);
	SensorValue[ledBoop7] = true;
	wait1Msec(300);
	SensorValue[ledBoop8] = true;
	wait1Msec(300);
	SensorValue[ledBoop9] = true;

}

void printData()
{
	while (true)
	{
		writeDebugStreamLine("sensor value: %d", SensorValue[temp];
		wait1Msec(250);
	}

}
/*
* meaure for ten seconds, every second
*/
void tempSense()
{
	printData();
	//toBinary(SensorValue[temp]);
}

void lightSense()

{
	//printData();
	//toBinary(SensorValue[light]/10);
	bool looping;
	while(looping){
		motor[rightMotor] = HALF_SPEED;
		motor[leftMotor] = HALF_SPEED;
		if(SensorValue[light]>2000){
			motor[rightMotor] = STATIONARY;
			motor[leftMotor] = STATIONARY;
			looping=false;
		}
	}
}

void windSense()
{
	int count;
	int now;
	int last = 0;
	while (count < 4) {
		now = SensorValue[wind];
		toBinary(now - last);
		last = now;
	}

}

void move()
{

	//turns off all the lights
	SensorValue[ledBoop1] = false;
	SensorValue[ledBoop2] = false;
	SensorValue[ledBoop3] = false;
	SensorValue[ledBoop4] = false;
	SensorValue[ledBoop5] = false;
	SensorValue[ledBoop6] = false;
	SensorValue[ledBoop7] = false;
	SensorValue[ledBoop8] = false;
	SensorValue[ledBoop9] = false;

	wait1Msec(1000);
	SensorValue[ledBoop1] = true;
	wait1Msec(100);
	SensorValue[ledBoop2] = true;
	wait1Msec(100);
	SensorValue[ledBoop3] = true;

	wait1Msec(100);
	SensorValue[ledBoop4] = true;
	wait1Msec(100);
	SensorValue[ledBoop5] = true;
	wait1Msec(100);
	SensorValue[ledBoop6] = true;
	wait1Msec(100);
	SensorValue[ledBoop7] = true;
	wait1Msec(100);
	SensorValue[ledBoop8] = true;
	wait1Msec(100);
	SensorValue[ledBoop9] = true;

	while(true) {
		if(vexRT[Btn7u] == 1){
			motor[rightMotor] = HALF_SPEED;
			motor[leftMotor] = -HALF_SPEED;
		}
		else if(vexRT[Btn7d] == 1){
			motor[rightMotor] = -HALF_SPEED;
			motor[leftMotor] = HALF_SPEED;
		}
		else if(vexRT[Btn7r] == 1){
			motor[rightMotor] = -HALF_SPEED;
			motor[leftMotor] = -HALF_SPEED;
		}
		else if(vexRT[Btn7l] == 1){
			motor[rightMotor] = HALF_SPEED;
			motor[leftMotor] = HALF_SPEED;
		}
		else{
			motor[rightMotor] = STATIONARY;
			motor[leftMotor] = STATIONARY;
		}
		if(vexRT[Btn6D] == 1){
			dropFlag();
		}
		if(vexRT[Btn5U] == 1){
			lightSense();
		}
		if(vexRT[Btn5D] == 1){
			autoMove();
		}
		if(vexRT[Btn6U] == 1){
			pullGravel();
		}
	}
}

task main()

{
	//left();
	//right();
	//printData();
	//lightSense();
	tempSense();
	//move();//sweet
}
